Types

All values in a translucid system are typed. The following text
describes how the types can be manipulated.


TypeRegistry

The type registry is the heart of the typing system. The type registry
stores information about all the types and allows the current types to
be queried, and typed values to be created. It holds the operations
associated with each type, and maintains information about the built
in types.


Basics

Each type has a name, a parser, a printer and a type index. Each type
must have a unique name. The name is used in a translucid expression
to refer to the type, the parser is used to construct a typed value
and is context dependent. The printer is used to print an already
existing typed value and is also context dependent.  The type index is
assigned by the type registry and is a faster way than the type name
to refer to types.


TypeManager

Each type has its own type manager. The type manager stores the name
of the type, the type registry that it was registered with, the index
that the registry assigned it, and the type's parser.


Making Custom Types

Two classes must be created for a custom type. The class which will
hold the actual typed value, and the type manager. To create a type
manager , derive from the TypeManager class. The parse function

virtual TypedValue parse(const Glib::ustring& text) const = 0;

must then be overridden. The parse function takes the current context
and the text to parse and returns a TypedValue which represents the
type with that value at that context.

The class which will hold the actual value must derive from
TypedValueBase. You must override the hash and print functions. The
hash value should create a hash with the usual meaning. Print should
output to the ostream the value at the current context.

class TypedValueBase {
   public:
   virtual void print(std::ostream& os, const Context& context) const = 0;
   virtual size_t hash() const = 0;
};
