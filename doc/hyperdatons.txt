Everything as a hyperdaton:

All the objects comply with the interface of a hyperdaton. This
interface is:

addExpr(k, E)
operator()(k)

Different hyperdatons respond to different dimensions. However there
are a couple of main types of hyperdatons. The system hyperdaton which
responds to the id dimension. The op hyperdatons which take
arg{0..inf}. The const hyperdatons which take the text.

Typed value has two concepts, a c++ data structure to store it, and
the TransLucid meaning. In TransLucid it is a constructor and a type
index.  The type index is used by the c++ implementation. When a new
type is created it is implemented by adding two equations to the
system.

CONST     | [type : "name"] = constructor
TYPEINDEX | [type : "name"] = unique-id

the constructor will respond to at least the text dimension

The unique IDs are obtained by calling _unique.

Note about parsing types.  We can write a new parser for a type
without knowing the internals of the type as long as we know an
appropriate input format then just call the more general version.

best fitting to make a new parser
CONST | [type : intmp, inputstyle : "words"] = ...
a symbol instead of "words" could improve speed here

dimensions:

the dimensions arg[0..inf] are reserved for function parameters

the system responds to the "id" dimension for identifiers
the @ [] on the lhs is in the dimension _validguard

CONST uses type and text

dimension indexes are stored in
DIMENSION_INDEX
   for named dimensions @ [text : string]
DIMENSION_TYPED_INDEX
   typed dimension in @ [value : tv]

identifiers:
constants are CONST
operations are OP
default int is in DEFAULTINT

constants that are defined:
uchar
intmp

constants that need defining:
bool
special
string

types:

things like special should be built by asking the system for a special
instead of just building it the index of a type could be part of the
system, anyone can ask for it, and then only if an implementation can
see the header declaration for the class of a type can it access the
type.

fixed dimensions and types:

it is required that some type and dimension indexes be fixed and
visible to everyone

   types:
      ustring     TYPE_INDEX_USTRING
      intmp       TYPE_INDEX_INTMP
      bool        TYPE_INDEX_BOOL
      special     TYPE_INDEX_SPECIAL
      uchar       TYPE_INDEX_UCHAR

   dimensions:
      type        DIM_TYPE
      text        DIM_TEXT
      name        DIM_NAME
      id          DIM_ID

operations and arg{0..inf}:

we need to work out how exactly to do this in TL, this requires the
default not found equation when the name is argN to add it return the
new index

TODO:
DIMENSION_INDEX needs to be defined and keep track of dimensions
this requires two things:
   - the fixed dimensions be registered
   - whenever the user looks up a dimension it registers it if it does not
     exist

DIMENSION_INDEX | [text : ustring] = ...;; - this is for a named dim
DIMENSION_INDEX | [value : any] = ...;; - this is for any other dim
... will be a special hyperdaton which is hooked up to the dim translator
class.

operations:
OP @ [op : ustring<operator?>, arg0 : intmp, arg1 : intmp] = 

we should guarantee certain conditions, for example that DEFAULTINT
will always work and construct the correct value unless a CONST error
occurs.

Printer:
We need a way to print these things.

PRINT = TYPENAME + "<" + 
   if PRINTVALUE : special then 
      PRINTVALUE @ [value : PRINTVALUE] 
   else 
      PRINTVALUE 
   fi
   + ">";;

PRINT should be guaranteed to return a string.

Examples:

identifier @ context is the same as
system @ [id : "identifier"];;

ustring<a string> will call:
CONST @ [type : "ustring", text : "a string"];;

Registering a dimension in the header like so:
dim<x>;;

will result in the following: 
u = _unique
DIMENSION_INDEX | [text : "x"] = u;;
or maybe the system can do this itself

to look up the index of a dimension:
when [x : 1] is seen the x will be translated to:
DIMENSION_INDEX | [text : "x"];;

_unique is a special thing in the implementation which increments itself
whenever it is called and returns the current value.

== Parsing ==

We should be able to create parsers using the system. These just
become hyperdatons and are used by adding more equations to the system
to parse things. In the meantime at least we can make the parser a
hyperdaton and types such as tuple can request a pointer to it so that
they can parse stuff inside <> at runtime.
